install.packages("shiny")
install.packages(c("MASS", "mcmcplots", "phytools", "R2jags"), lib="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
install.packages("shiny", lib="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
install.packages(c("devtools", "markdown", "MASS", "phytools", "Rcpp"))
install.packages(c("DirichletReg", "ggm", "ggmap", "ggplot2", "ggtern", "ggthemes"), lib="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
true.mean<-170
true.sd<-10
y<-round(rnorm(20,mean=true.mean,sd=true.sd))
mod<-lm(y~1)
summary(mod)
summary(mod)$sigma
str(mod)
summary(mod)
y
23^5
57^5
691^5
69^5
library(rjags)
library(ggmcmc)
library(ggplot2)
library(ggthemes)
library(pander)
library(Cairo)
library(plyr)
library(MASS)
library(scales)
library(plyr)
require(gdata)
require(runjags)
require(gdata)
covariate<-round(runif(250,20,70))
response<-rnorm(250,13.5,1)
knot0<-c()
for(i in 1:15){
knot0[i]<-i/(15+1)
}
nos<-quantile(covariate,knot0)
jags.data <-list(n=250,nknots=15,degree=2,knot=nos)
model<-"model{
#Begin model
#
#Likelihood of the model
for (i in 1:n)
{response[i]~dnorm(m[i],taueps)
m[i]<-inprod(beta[],X[i,])+inprod(b[],Z[i,])}
#Prior distributions of the random effects parameters
for (k in 1:nknots){b[k]~dnorm(0,taub)}
#Prior distribution of the fixed effects parameters
for (l in 1:degree+1){beta[l]~dnorm(0,1.0E-6)}
#Prior distributions of the precision parameters
taueps~dgamma(1.0E-3,1.0E-3); taub~dgamma(1.0E-3,1.0E-3)
#Construct the design matrix of fixed effects
for (i in 1:n)
{for (l in 1:degree+1){X[i,l]<-pow(covariate[i],l-1)}}
#Construct the design matrix of random effects
for (i in 1:n)
{for (k in 1:nknots)
{u[i,k]<-(covariate[i]-knot[k])*step(covariate[i]-knot[k])
Z[i,k]<-pow(u[i,k],degree)}}
#Deterministic transformations. Obtain the standard deviations and
#the smoothing parameter
sigmaeps<-1/sqrt(taueps);sigmab<-1/sqrt(taub)
lambda<-pow(sigmab,2)/pow(sigmaeps,2)
#Predicting new observations
for (i in 1:n)
{epsilonstar[i]~dnorm(0,taueps)
ystar[i]<-m[i]+epsilonstar[i]}
}"
params<-c("beta","ystar","b")
inits0  <- function () {
list(beta  = rnorm(1, 0, 0.01),
b = rnorm(1, 0, 0.01)
)  }
inits1=inits0()
inits2=inits0()
inits3=inits0()
library(parallel)
cl <- makeCluster(3)
jags.logit <- run.jags(method="rjparallel",
data = jags.data,
inits = list(inits1,inits2,inits3),
model=model,
n.chains = 3,
adapt=1500,
monitor=c(params),
burnin=1000,
sample=5000,
summarise=FALSE,
plots=FALSE
)
library(rjags)
library(ggmcmc)
library(ggplot2)
library(ggthemes)
library(pander)
library(Cairo)
library(plyr)
library(MASS)
library(scales)
library(plyr)
require(gdata)
require(runjags)
require(gdata)
covariate<-round(runif(250,20,70))
response<-rnorm(250,13.5,1)
knot0<-c()
for(i in 1:15){
knot0[i]<-i/(15+1)
}
nos<-quantile(covariate,knot0)
jags.data <-list(n=250,
nknots=15,
degree=2,
knot=nos)
model<-"model{
#Begin model
#
#Likelihood of the model
for (i in 1:n)
{response[i]~dnorm(m[i],taueps)
m[i]<-inprod(beta[],X[i,])+inprod(b[],Z[i,])}
#Prior distributions of the random effects parameters
for (k in 1:nknots){b[k]~dnorm(0,taub)}
#Prior distribution of the fixed effects parameters
for (l in 1:degree+1){beta[l]~dnorm(0,1.0E-6)}
#Prior distributions of the precision parameters
taueps~dgamma(1.0E-3,1.0E-3); taub~dgamma(1.0E-3,1.0E-3)
#Construct the design matrix of fixed effects
for (i in 1:n)
{for (l in 1:degree+1){X[i,l]<-pow(covariate[i],l-1)}}
#Construct the design matrix of random effects
for (i in 1:n)
{for (k in 1:nknots)
{u[i,k]<-(covariate[i]-knot[k])*step(covariate[i]-knot[k])
Z[i,k]<-pow(u[i,k],degree)}}
#Deterministic transformations. Obtain the standard deviations and
#the smoothing parameter
sigmaeps<-1/sqrt(taueps);sigmab<-1/sqrt(taub)
lambda<-pow(sigmab,2)/pow(sigmaeps,2)
#Predicting new observations
for (i in 1:n)
{epsilonstar[i]~dnorm(0,taueps)
ystar[i]<-m[i]+epsilonstar[i]}
}"
params<-c("beta","ystar","b")
inits0  <- function () {
list(beta  = rnorm(1, 0, 0.01),
b = rnorm(1, 0, 0.01)
)  }
inits1=inits0()
inits2=inits0()
inits3=inits0()
library(parallel)
cl <- makeCluster(3)
jags.logit <- run.jags(method="rjparallel",
data = jags.data,
inits = list(inits1,inits2,inits3),
model=model,
n.chains = 3,
adapt=1500,
monitor=c(params),
burnin=1000,
sample=5000,
summarise=FALSE,
plots=FALSE
)
knot
knot=nos
knot
knot[1]
knot[2]
knot[3]
knot[[3]]
nos[1]
nos[[]]
nos[[1]]
nos[[1:15]]
nos[1:15]
nos[1:15][]
as.list(nos)
as.numeric(nos)
jags.data <-list(n=250,
nknots=15,
degree=2,
knot=as.numeric(nos))
model<-"model{
#Begin model
#Likelihood of the model
for (i in 1:n){
response[i]~dnorm(m[i],taueps)
m[i]<-inprod(beta[],X[i,])+inprod(b[],Z[i,])}
#Prior distributions of the random effects parameters
for (k in 1:nknots){b[k]~dnorm(0,taub)}
#Prior distribution of the fixed effects parameters
for (l in 1:degree+1){beta[l]~dnorm(0,1.0E-6)}
#Prior distributions of the precision parameters
taueps~dgamma(1.0E-3,1.0E-3)
taub~dgamma(1.0E-3,1.0E-3)
#Construct the design matrix of fixed effects
for (i in 1:n){
for (l in 1:degree+1){
X[i,l]<-pow(covariate[i],l-1)
}
#Construct the design matrix of random effects
for (i in 1:n){
for (k in 1:nknots){
u[i,k]<-(covariate[i]-knot[k])*step(covariate[i]-knot[k])
Z[i,k]<-pow(u[i,k],degree)
}
#Deterministic transformations. Obtain the standard deviations and
#the smoothing parameter
sigmaeps<-1/sqrt(taueps);sigmab<-1/sqrt(taub)
lambda<-pow(sigmab,2)/pow(sigmaeps,2)
#Predicting new observations
for (i in 1:n){
epsilonstar[i]~dnorm(0,taueps)
ystar[i]<-m[i]+epsilonstar[i]
}
}"
params<-c("beta","ystar","b")
inits0  <- function () {
list(beta  = rnorm(1, 0, 0.01),
b = rnorm(1, 0, 0.01)
)  }
inits1=inits0()
inits2=inits0()
inits3=inits0()
library(parallel)
cl <- makeCluster(3)
jags.logit <- run.jags(method="rjparallel",
data = jags.data,
inits = list(inits1,inits2,inits3),
model=model,
n.chains = 3,
adapt=1500,
monitor=c(params),
burnin=1000,
sample=5000,
summarise=FALSE,
plots=FALSE
)
library("R2WinBUGS", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
bugs(data = jags.data,inits1,params,model,n.chains = 3,n.iter=5000)
bugs(data = jags.data,inits,params,model,n.chains = 3,n.iter=5000)
inits = list(inits1,inits2,inits3)
bugs(data = jags.data,inits,params,model,n.chains = 3,n.iter=5000)
par(mfrow = c(2, 1))
x <- rchisq(1000, df = 4)
hs <- hist(x, breaks = 15)
hist3D(x = hs$mids, y = 1, z = matrix(ncol = 1, data = hs$density),
bty = "g", ylim = c(0., 2.0), scale = FALSE, expand = 20,
border = "black", col = "white", shade = 0.3, space = 0.1,
theta = 20, phi = 20, main = "3-D perspective")
library("plot3D", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
par(mfrow = c(2, 1))
x <- rchisq(1000, df = 4)
hs <- hist(x, breaks = 15)
hist3D(x = hs$mids, y = 1, z = matrix(ncol = 1, data = hs$density),
bty = "g", ylim = c(0., 2.0), scale = FALSE, expand = 20,
border = "black", col = "white", shade = 0.3, space = 0.1,
theta = 20, phi = 20, main = "3-D perspective")
par(mfrow = c(2, 1))
x <- rchisq(1000, df = 4)
hs <- hist(x, breaks = 15)
hist3D(x = hs$mids, y = 1, z = matrix(ncol = 1, data = hs$density),
bty = "g", ylim = c(0., 2.0), scale = FALSE, expand = 20,
border = "black", col = "white", shade = 0.3, space = 0.1,
theta = 20, phi = 20, main = "3-D perspective")
par(mfrow = c(2, 1))
x <- rchisq(1000, df = 4)
hs <- hist(x, breaks = 15)
x
hist(x, breaks = 15)
hs <- hist(x, breaks = 15)
hist3D(x = hs$mids, y = 1, z = matrix(ncol = 1, data = hs$density),
bty = "g", ylim = c(0., 2.0), scale = FALSE, expand = 20,
border = "black", col = "white", shade = 0.3, space = 0.1,
theta = 20, phi = 20, main = "3-D perspective")
x <- seq(-pi, pi, by = 0.2)
y <- seq(-pi, pi, by = 0.3)
grid <- mesh(x, y)
z    <- with(grid, cos(x) * sin(y))
par(mfrow = c(2,2))
persp3D(z = z, x = x, y = y)
persp3D(z = z, x = x, y = y, facets = FALSE, curtain = TRUE)
# ribbons in two directions and larger spaces
ribbon3D(z = z, x = x, y = y, along = "xy", space = 0.3)
hist3D(z = z, x = x, y = y, border = "black")
par(mfrow = c(2, 2))
VV   <- volcano[seq(1, 87, 15), seq(1, 61, 15)]
hist3D(z = VV, scale = FALSE, expand = 0.01)
# transparent colors
hist3D(z = VV, scale = FALSE, expand = 0.01,
col = jet.col(100, alpha = 0.3), border = "black")
hist3D(z = VV, scale = FALSE, expand = 0.01, facets = FALSE, lwd = 2)
hist3D(z = VV, scale = FALSE, expand = 0.01, facets = NA)
AGN_data<-read.table("../data/outputdata.txt",header=TRUE,sep="")
setwd("~/Dropbox/artigos/Meusartigos/IAA-WGC/Github/GLM_AGN/script")
AGN_data<-read.table("../data/outputdata.txt",header=TRUE,sep="")
head(AGN_data)
colnames(AGN_data)
require(arm)
colnames(AGN_data)
AGN_data$WHAN_Class
as.factor(AGN_data$WHAN_Class)
AGN_data$WHAN_Class<-as.factor(AGN_data$WHAN_Class)
revalue(AGN_data$WHAN_Class,c("2"="1","3"="1","1"="0","4"="0"))
require(ply)
require(plyr)
revalue(AGN_data$WHAN_Class,c("2"="1","3"="1","1"="0","4"="0"))
AGN_data$WHAN_Class<-revalue(AGN_data$WHAN_Class,c("2"="1","3"="1","1"="0","4"="0"))
colnames(AGN_data)
fit<-bayesglm(WHAN_Class~log10.NII.Ha.+log10.EW.Ha..,family=binomial(link="logit"),scaled=TRUE,
data = AGN_data)
fit
ROCF<- data.frame(True=AGN_data$WHAN_Class,predicted=predict(fit,type = "response"))
F1 <-roc(ROCF$True,ROCF$predicted)
coords(F1,x="best")[1]
confusion.matrix(ROCF$True, ROCF$predicted, threshold = coords(F1,x="best")[1])
library(caret)
ROCF<- data.frame(True=AGN_data$WHAN_Class,predicted=predict(fit,type = "response"))
F1 <-roc(ROCF$True,ROCF$predicted)
coords(F1,x="best")[1]
confusion.matrix(ROCF$True, ROCF$predicted, threshold = coords(F1,x="best")[1])
library(pROC)
confusionMatrix(ROCF$True, ROCF$predicted, threshold = coords(F1,x="best")[1])
ROCF
F1 <-roc(ROCF$True,ROCF$predicted)
F1
plot(F1)
coords(F1,x="best")[1]
confusionMatrix(ROCF$True, ROCF$predicted, threshold = coords(F1,x="best")[1])
ROCF$True
ROCF$predicted
coords(F1,x="best")[1]
levels(ROCF$True)
levels(ROCF$predicted)
predict(fit,type = "prob")
predicted[, "yes"]
predicted=predict(fit,type = "response")
predicted[, "yes"]
ROCF$predicted
ROCF$class
ROCF$class<-ROCF2$predicted
ROCF$class[which(ROCF$class>=coords(F1,x="best")[1])]<-1
ROCF$class[which(ROCF$class<coords(F1,x="best")[1])]<-0
ROCF$class<-ROCF$predicted
ROCF$class[which(ROCF$class>=coords(F1,x="best")[1])]<-1
ROCF$class[which(ROCF$class<coords(F1,x="best")[1])]<-0
confusionMatrix(ROCF$True, ROCF$class, threshold = coords(F1,x="best")[1])
ROCF$class
ROCF$True
confusionMatrix(ROCF$True, ROCF$class)
library(rsm)
library(lattice)
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
p<-persp(x,y,z, theta=150, phi=20,
expand = 0.5,shade = 0.1,
xlab="Z", ylab=expression(NII.Ha), zlab=expression(log10.EW.Ha),ticktype='detailed',
col = YlOrBr,border=NA,xlog=T,ylog=T)
cor = topo.colors(200)
x <-range(AGN_data$log10.NII.Ha)
x <- seq(x[1], x[2], length.out=50)
y <- range(AGN_data$log10.EW.Ha..)
y <- seq(y[1], y[2], length.out=50)
z <- outer(x,y,
function(log10.NII.Ha,log10.EW.Ha..)
predict(fit, data.frame(log10.NII.Ha,log10.EW.Ha..),type = 'response'))
library(rsm)
library(lattice)
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
p<-persp(x,y,z, theta=150, phi=20,
expand = 0.5,shade = 0.1,
xlab="Z", ylab=expression(NII.Ha), zlab=expression(log10.EW.Ha),ticktype='detailed',
col = YlOrBr,border=NA,xlog=T,ylog=T)
cor = topo.colors(200)
outer(x,y,
function(log10.NII.Ha,log10.EW.Ha..)
predict(fit, data.frame(log10.NII.Ha,log10.EW.Ha..),type = 'response'))
x <-range(AGN_data$log10.NII.Ha.)
x <- seq(x[1], x[2], length.out=50)
y <- range(AGN_data$log10.EW.Ha..)
y <- seq(y[1], y[2], length.out=50)
z <- outer(x,y,
function(log10.NII.Ha,log10.EW.Ha..)
predict(fit, data.frame(log10.NII.Ha.,log10.EW.Ha..),type = 'response'))
library(rsm)
library(lattice)
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
p<-persp(x,y,z, theta=150, phi=20,
expand = 0.5,shade = 0.1,
xlab="Z", ylab=expression(NII.Ha), zlab=expression(log10.EW.Ha),ticktype='detailed',
col = YlOrBr,border=NA,xlog=T,ylog=T)
cor = topo.colors(200)
z <- outer(x,y,
function(log10.NII.Ha.,log10.EW.Ha..)
predict(fit, data.frame(log10.NII.Ha.,log10.EW.Ha..),type = 'response'))
library(rsm)
library(lattice)
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
p<-persp(x,y,z, theta=150, phi=20,
expand = 0.5,shade = 0.1,
xlab="Z", ylab=expression(NII.Ha), zlab=expression(log10.EW.Ha),ticktype='detailed',
col = YlOrBr,border=NA,xlog=T,ylog=T)
cor = topo.colors(200)
trellis.par.set("axis.line",list(axis.text=list(cex=20),col=NA,lty=1,lwd=2))
par(mar=c(1,1,1,1))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(Z~(Z['\u0298'])),cex=1.25), ylab=list(label=expression(x[mol]),cex=1.25), zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(x =list(log = 10),tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
p
trellis.par.set("axis.line",list(axis.text=list(cex=20),col=NA,lty=1,lwd=2))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(Z~(Z['\u0298'])),cex=1.25), ylab=list(label=expression(x[mol]),cex=1.25), zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(x =list(log = 10),tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
persp(x,y,z, theta=150, phi=20,
expand = 0.5,shade = 0.1,
xlab="Z", ylab=expression(NII.Ha), zlab=expression(log10.EW.Ha),ticktype='detailed',
col = YlOrBr,border=NA,xlog=T,ylog=T)
p
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(Z~(Z['\u0298'])),cex=1.25), ylab=list(label=expression(x[mol]),cex=1.25), zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(x =list(log = 10),tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
z
y
x
y
z
is.na(z)
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(Z~(Z['\u0298'])),cex=1.25), ylab=list(label=expression(x[mol]),cex=1.25), zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(x =list(log = 10),tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(Z~(Z['\u0298'])),cex=1.25), ylab=list(label=expression(x[mol]),cex=1.25), zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(Z~(Z['\u0298'])),cex=1.25), ylab=list(label=expression(x[mol]),cex=1.25),
zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(Z~(Z['\u0298'])),cex=1.25), ylab=list(label=expression(x[mol]),cex=1.25),
zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(log10.NII.Ha.),cex=1.25), ylab=list(label=expression(log10.EW.Ha..),cex=1.25),
zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(log10.NII.Ha.),cex=1.25), ylab=list(label=expression(log10.EW.Ha..),cex=1.25),
zlab=list(rot=120,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(log10.NII.Ha.),cex=1.25), ylab=list(label=expression(log10.EW.Ha..),cex=1.25),
zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
confusionMatrix(ROCF$True, ROCF$class)
trellis.par.set("axis.line",list(axis.text=list(cex=20),col=NA,lty=1,lwd=2))
par(mar=c(1,1,1,1))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(log10.NII.Ha.),cex=1.25), ylab=list(label=expression(log10.EW.Ha..),cex=1.25),
zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=90),
scale=list(tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
trellis.par.set("axis.line",list(axis.text=list(cex=20),col=NA,lty=1,lwd=2))
par(mar=c(1,1,1,1))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(log10.NII.Ha.),cex=1.25), ylab=list(label=expression(log10.EW.Ha..),cex=1.25),
zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=120),
scale=list(tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
trellis.par.set("axis.line",list(axis.text=list(cex=20),col=NA,lty=1,lwd=2))
par(mar=c(1,1,1,1))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(log10.NII.Ha.),cex=1.25), ylab=list(label=expression(log10.EW.Ha..),cex=1.25),
zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=180),
scale=list(tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
trellis.par.set("axis.line",list(axis.text=list(cex=20),col=NA,lty=1,lwd=2))
par(mar=c(1,1,1,1))
wireframe(z~x+y,data=data.frame(x=x, y=rep(y, each=length(x)), z=z),
par.settings = list(regions=list(alpha=0.4)),
col.regions =cor,drape=T,light.source = c(5,5,5),colorkey = FALSE,
xlab=list(label=expression(log10.NII.Ha.),cex=1.25), ylab=list(label=expression(log10.EW.Ha..),cex=1.25),
zlab=list(rot=90,label=expression(pi),cex=1.25,dist=-1,rot=0),
scale=list(tck=0.75,arrows=FALSE,distance =c(0.75, 0.75, 0.75)))
